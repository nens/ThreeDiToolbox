# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThreeDiCustomStatsDialog
                                 A QGIS plugin
 This plugin calculates statistics of 3Di results. The user chooses the variable, aggregation method and
 spatiotemperal filtering.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-11-27
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Leendert van Wolfswinkel | Nelen en Schuurmans
        email                : leendert.vanwolfswinkel@nelen-schuurmans.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import sys
from types import MethodType
from typing import List

from qgis.PyQt import QtWidgets
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QPersistentModelIndex
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsProject, QgsCoordinateReferenceSystem
from qgis.gui import QgsFileWidget
from threedigrid.admin.gridresultadmin import GridH5ResultAdmin
from threedi_results_analysis.threedi_plugin_model import ThreeDiResultItem
from threedi_results_analysis.utils.user_messages import pop_up_critical

import logging


logger = logging.getLogger(__name__)

from .presets import PRESETS, Preset, NO_PRESET
from threedi_results_analysis.utils.threedi_result_aggregation.base import get_threshold_attributes
from threedi_results_analysis.utils.threedi_result_aggregation.aggregation_classes import (
    Aggregation,
    AggregationMethod,
    AggregationSign,
    AggregationVariable,
    filter_demanded_aggregations,
    VT_NAMES,
    VT_FLOW,
    VT_FLOW_HYBRID,
    VT_NODE,
    VT_NODE_HYBRID,
    VT_PUMP,
    VR_INTERFLOW,
    VR_SIMPLE_INFILTRATION,
    VR_INTERCEPTION,
    VR_PUMP,
    VR_NAMES,
)
from threedi_results_analysis.utils.threedi_result_aggregation.constants import (
    AGGREGATION_VARIABLES,
    AGGREGATION_METHODS,
    AGGREGATION_SIGNS,
    NA_TEXT,
)

from .style import (
    DEFAULT_STYLES,
    STYLES,
    Style
)

# This loads the .ui file so that PyQt can populate the plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(
    os.path.join(
        os.path.dirname(__file__), "threedi_custom_stats_dialog_base.ui"
    )
)

DEFAULT_AGGREGATION = Aggregation(
    variable=AGGREGATION_VARIABLES.get_by_short_name("q"),
    sign=AggregationSign(short_name="net", long_name="Net"),
    method=AGGREGATION_METHODS.get_by_short_name("sum"),
)

COLUMN_VARIABLE = 0
COLUMN_DIRECTION = 1
COLUMN_METHOD = 2
COLUMN_THRESHOLD_ATTRIBUTE = 3
COLUMN_THRESHOLD_VALUE = 4
COLUMN_UNITS = 5

FLOWLINES_TAB = 0
NODES_CELLS_TAB = 1
PUMPS_TAB = 2
RASTERS_TAB = 3


def update_column_widget(
    self: QtWidgets.QComboBox, demanded_aggregations: List[Aggregation], aggregation_variable_types: List
):
    """
    This method is intended to be bound to QComboBox after instantiation

    Adds the `as_column_name()` string representations of the `demanded_aggregations` as items to `self`
    if the aggregation variable type is in `aggregation_variable_types`
    """
    self.clear()
    filtered_das = filter_demanded_aggregations(
        das=demanded_aggregations, variable_types=aggregation_variable_types
    )
    for da in filtered_das:
        column_name = da.as_column_name()
        if column_name is not None:
            self.addItem(da.as_column_name())
    self.addItem("")


class ThreeDiCustomStatsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, model, parent=None):
        """Constructor."""
        super(ThreeDiCustomStatsDialog, self).__init__(parent)
        self.setupUi(self)
        self.iface = iface
        self.model = model

        self.gr = None
        self.result_id = None
        self.demanded_aggregations = []

        for preset in PRESETS:
            self.comboBoxPreset.addItem(preset.name)
            self.comboBoxPreset.setItemData(
                self.comboBoxPreset.count() - 1, preset
            )
        self.comboBoxPreset.currentIndexChanged.connect(
            self.preset_combobox_changed
        )

        self.pushButtonAddAggregation.clicked.connect(self.add_aggregation)
        self.pushButtonRemoveAggregation.clicked.connect(
            self.remove_aggregation
        )
        self.add_aggregation()
        for column_index in [
            COLUMN_VARIABLE,
            COLUMN_DIRECTION,
            COLUMN_METHOD,
            COLUMN_THRESHOLD_ATTRIBUTE,
            COLUMN_THRESHOLD_VALUE,
        ]:
            self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(
                column_index, QtWidgets.QHeaderView.Stretch
            )

        # Populate the combobox with the results

        self.resultComboBox.activated.connect(self.results_3di_selected)
        self._populate_results()
        self.resultComboBox.setCurrentIndex(-1)

        self.pushButtonMapCanvas.clicked.connect(self.set_extent_from_map_canvas)
        self.set_extent_from_map_canvas()
        self.mExtentGroupBox.setChecked(False)

        self.init_styling_tab()
        self.set_styling_tab()

        self.dialogButtonBoxOKCancel.button(
            QtWidgets.QDialogButtonBox.Ok
        ).setEnabled(False)

    def _populate_results(self) -> None:
        self.resultComboBox.clear()
        for result in self.model.get_results(checked_only=False):
            self.resultComboBox.addItem(f"{result.parent().text()} | {result.text()}", result.id)

    def add_aggregation(
        self, *args, aggregation: Aggregation = DEFAULT_AGGREGATION, update_output_layer_names: bool = True
    ):
        """Add a new row to tableWidgetAggregations, always last row"""
        self.tableWidgetAggregations.insertRow(
            self.tableWidgetAggregations.rowCount()
        )
        current_row = self.tableWidgetAggregations.rowCount() - 1

        # variable column
        variable_combobox = QtWidgets.QComboBox()
        for i, variable in enumerate(AGGREGATION_VARIABLES):
            variable_combobox.addItem(
                VT_NAMES[variable.var_type] + ": " + variable.long_name
            )
            variable_combobox.setItemData(i, variable)
        idx = variable_combobox.findText(
            aggregation.variable.long_name, Qt.MatchEndsWith
        )
        variable_combobox.setCurrentIndex(idx)
        variable_combobox.activated.connect(
            self.variable_combobox_text_changed
        )
        self.tableWidgetAggregations.setCellWidget(
            current_row, COLUMN_VARIABLE, variable_combobox
        )

        # sign column
        direction_combobox = QtWidgets.QComboBox()
        counter = 0
        for s in AGGREGATION_SIGNS:
            direction_combobox.addItem(s.long_name)
            direction_combobox.setItemData(counter, s)
            counter += 1
        direction_combobox.setCurrentText(aggregation.sign.long_name)
        self.tableWidgetAggregations.setCellWidget(
            current_row, COLUMN_DIRECTION, direction_combobox
        )
        direction_combobox.currentTextChanged.connect(
            self.direction_combobox_text_changed
        )

        # method column
        method_combobox = QtWidgets.QComboBox()
        for i, method_str in enumerate(
            aggregation.variable.applicable_methods
        ):
            method = AGGREGATION_METHODS.get_by_short_name(method_str)
            method_combobox.addItem(method.long_name)
            method_combobox.setItemData(i, method)
        if aggregation.method:
            method_combobox.setCurrentText(aggregation.method.long_name)
        self.tableWidgetAggregations.setCellWidget(
            current_row, COLUMN_METHOD, method_combobox
        )
        method_combobox.currentTextChanged.connect(
            self.method_combobox_text_changed
        )

        # threshold column
        method = method_combobox.currentData()
        variable = variable_combobox.currentData()
        self.set_threshold_attribute_widget(row=current_row, variable=variable, method=method)
        self.set_threshold_value_widget(row=current_row, method=method)

        # units column
        units_combobox = QtWidgets.QComboBox()
        self.tableWidgetAggregations.setCellWidget(
            current_row, COLUMN_UNITS, units_combobox
        )
        self.set_units_widget(
            row=current_row,
            variable=variable_combobox.itemData(
                variable_combobox.currentIndex()
            ),
            method=method,
        )

        # set the threshold _after_ the units widget is in place
        if aggregation.threshold is not None:
            threshold_widget = self.tableWidgetAggregations.cellWidget(current_row, COLUMN_THRESHOLD_VALUE)
            if method.threshold_sources:
                threshold_widget.setCurrentIndex(
                    threshold_widget.findText(aggregation.threshold),
                )
            else:
                threshold_widget.setValue(aggregation.threshold)

        # TODO: dit is nu lastig te setten obv aggregation, omdat die wel een attribuut multiplier heeft,
        #  maar niet een attribuut units. laat ik nu even voor wat het is
        units_combobox.currentTextChanged.connect(
            self.units_combobox_text_changed
        )

        self.update_demanded_aggregations()
        self.set_styling_tab()
        if update_output_layer_names:
            self._update_output_layer_fields_based_on_aggregations()
        self.validate()
        self._update_variable_list()

    def remove_aggregation(self):
        index_list = []
        for (
            model_index
        ) in self.tableWidgetAggregations.selectionModel().selectedRows():
            index = QPersistentModelIndex(model_index)
            index_list.append(index)

        for index in index_list:
            self.tableWidgetAggregations.removeRow(index.row())

        self.update_demanded_aggregations()
        self._update_output_layer_fields_based_on_aggregations()
        self.validate()

    def variable_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_VARIABLE)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        self.set_method_widget(row, variable)
        self.set_direction_widget(row, variable)
        self.set_units_widget(row=row, variable=variable, method=None)
        self.update_demanded_aggregations()
        self._update_output_layer_fields_based_on_aggregations()
        self.validate()

    def method_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_VARIABLE)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        method_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_METHOD)
        method = method_widget.itemData(method_widget.currentIndex())
        self.set_threshold_value_widget(row=row, method=method)
        self.set_units_widget(row=row, variable=variable, method=method)
        self.update_demanded_aggregations()
        self._update_output_layer_fields_based_on_aggregations()

    def direction_combobox_text_changed(self):
        self.update_demanded_aggregations()
        self._update_output_layer_fields_based_on_aggregations()

    def threshold_value_changed(self):
        self.update_demanded_aggregations()

    def units_combobox_text_changed(self):
        self.update_demanded_aggregations()
        self._update_output_layer_fields_based_on_aggregations()

    def set_direction_widget(self, row, variable):
        na_index = self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).findText(
            NA_TEXT
        )
        if variable.signed:
            if na_index != -1:
                self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).removeItem(
                    na_index
                )
            self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).setCurrentIndex(0)
        else:
            if na_index == -1:
                self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).addItem(
                    NA_TEXT
                )
                na_index = self.tableWidgetAggregations.cellWidget(
                    row, 1
                ).findText(NA_TEXT)
            self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).setCurrentIndex(
                na_index
            )
        self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION).setEnabled(
            variable.signed
        )

    def set_method_widget(self, row, variable):
        method_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_METHOD)
        method_widget.blockSignals(True)
        method_widget.setEnabled(False)
        method_widget.clear()
        if variable.applicable_methods:
            for method_short_name in variable.applicable_methods:
                method = AGGREGATION_METHODS.get_by_short_name(method_short_name)
                method_widget.addItem(method.long_name, method)
                method_widget.setEnabled(True)
        method_widget.blockSignals(False)
        method = method_widget.itemData(method_widget.currentIndex())
        self.set_threshold_value_widget(row=row, method=method)

    def set_threshold_attribute_widget(self, row: int, variable: AggregationVariable, method: AggregationMethod):
        threshold_attribute_widget = QtWidgets.QComboBox()
        if method and variable:
            threshold_attributes = get_threshold_attributes(gridadmin=self.gr, var_type=variable.var_type)
            threshold_attribute_widget.addItem("constant")
            threshold_attribute_widget.setItemData(0, None)
            for i, (field_name, display_name) in enumerate(threshold_attributes):
                threshold_attribute_widget.addItem(display_name)
                threshold_attribute_widget.setItemData(i, variable)

        threshold_attribute_widget.setEnabled(method is not None and method.has_threshold)
        self.tableWidgetAggregations.setCellWidget(row, COLUMN_THRESHOLD_ATTRIBUTE, threshold_attribute_widget)
        threshold_attribute_widget.currentIndexChanged.connect(self.threshold_value_changed)

    def set_threshold_value_widget(self, row, method):
        threshold_value_widget = QtWidgets.QDoubleSpinBox()
        threshold_value_widget.setRange(sys.float_info.min, sys.float_info.max)
        threshold_value_widget.setEnabled(method is not None and method.has_threshold)
        self.tableWidgetAggregations.setCellWidget(row, COLUMN_THRESHOLD_VALUE, threshold_value_widget)
        threshold_value_widget.valueChanged.connect(self.threshold_value_changed)

    def set_units_widget(self, row, variable, method):
        """Called when variable or method changes"""
        units_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_UNITS)
        units_widget.clear()

        if not method:
            text = next(iter(variable.units.items()))[0][0]
            return units_widget.addItem(text, 1)
        if method.is_percentage:
            return units_widget.addItem("%", 1)
        if method.is_duration:
            return units_widget.addItem("s", 1)

        for i, (units, multiplier_tuple) in enumerate(variable.units.items()):
            multiplier = multiplier_tuple[0]
            if method.integrates_over_time:
                units_str = units[0]
            else:
                units_str = "/".join(units)
                if len(multiplier_tuple) == 2:
                    multiplier *= multiplier_tuple[1]
            # add item to the widget if no similar item exists:
            if not any(
                units_str in units_widget.itemText(x)
                for x in range(units_widget.count())
            ):
                units_widget.addItem(units_str, multiplier)

    def get_styling_parameters(self, output_type):
        params_widgets = {
            "node": self.tableWidgetNodesStyleParams,
            "flowline": self.tableWidgetFlowlinesStyleParams,
            "cell": self.tableWidgetCellsStyleParams,
            "pump": self.tableWidgetPumpsStyleParams,
            "pump_linestring": self.tableWidgetPumpsLinestringStyleParams,
        }
        params_widget = params_widgets[output_type]
        result = {}
        for row in range(params_widget.rowCount()):
            result[
                params_widget.item(row, 0).text()
            ] = params_widget.cellWidget(row, 1).currentText()
        return result

    def init_styling_tab(self):
        type_widgets = {
            "flowline": self.comboBoxFlowlinesStyleType,
            "node": self.comboBoxNodesStyleType,
            "cell": self.comboBoxCellsStyleType,
            "pump": self.comboBoxPumpsStyleType,
            "pump_linestring": self.comboBoxPumpsLinestringStyleType,
        }
        for style in STYLES:
            type_widget = type_widgets[style.output_type]
            row = type_widget.count()
            type_widget.addItem(style.name)
            type_widget.setItemData(row, style)

        self.checkbox_flowlines_state_changed()
        self.checkBoxFlowlines.stateChanged.connect(self.checkbox_flowlines_state_changed)
        self.checkbox_nodes_state_changed()
        self.checkBoxNodes.stateChanged.connect(self.checkbox_nodes_state_changed)
        self.checkbox_cells_state_changed()
        self.checkBoxCells.stateChanged.connect(self.checkbox_cells_state_changed)
        self.checkbox_pumps_state_changed()
        self.checkBoxPumps.stateChanged.connect(self.checkbox_pumps_state_changed)
        self.checkbox_pumps_linestring_state_changed()
        self.checkBoxPumpsLinestring.stateChanged.connect(self.checkbox_pumps_linestring_state_changed)
        self.checkbox_rasters_state_changed()
        self.checkBoxRasters.stateChanged.connect(self.checkbox_rasters_state_changed)

        self.comboBoxFlowlinesStyleType.currentIndexChanged.connect(
            self.flowline_styling_type_changed
        )
        self.comboBoxNodesStyleType.currentIndexChanged.connect(
            self.node_styling_type_changed
        )
        self.comboBoxCellsStyleType.currentIndexChanged.connect(
            self.cell_styling_type_changed
        )
        self.comboBoxPumpsStyleType.currentIndexChanged.connect(
            self.pump_styling_type_changed
        )
        self.comboBoxPumpsLinestringStyleType.currentIndexChanged.connect(
            self.pump_linestring_styling_type_changed
        )
        self.doubleSpinBoxResolution.valueChanged.connect(
            self.raster_resolution_changed
        )
        self.doubleSpinBoxNodesLayerResolution.valueChanged.connect(
            self.nodes_layer_resolution_changed
        )
        self.mQgsFileWidgetRasterFolder.setStorageMode(
            QgsFileWidget.GetDirectory
        )
        self.mQgsFileWidgetRasterFolder.fileChanged.connect(self.validate)

    def set_styling_tab(
        self,
        flowlines_style: Style = None,
        nodes_style: Style = None,
        cells_style: Style = None,
        pumps_style: Style = None,
        pumps_linestring_style: Style = None,

        flowlines_style_param_values: dict = None,
        cells_style_param_values: dict = None,
        nodes_style_param_values: dict = None,
        pumps_style_param_values: dict = None,
        pumps_linestring_style_param_values: dict = None,

        uncheck_flowlines_checkbox: bool = False,
        uncheck_nodes_checkbox: bool = False,
        uncheck_cells_checkbox: bool = False,
        uncheck_pumps_checkbox: bool = False,
        uncheck_pumps_linestring_checkbox: bool = False,
    ):
        """
        Styles can be set (e.g. when a preset is used) or be None so the default for the first variable is used
        """
        # Flowlines
        filtered_das = filter_demanded_aggregations(
            self.demanded_aggregations, [VT_FLOW, VT_FLOW_HYBRID]
        )
        if len(filtered_das) > 0:
            if flowlines_style is None:
                flowlines_style_name = DEFAULT_STYLES[
                    filtered_das[0].variable.short_name
                ]["flowline"].name
            else:
                flowlines_style_name = flowlines_style.name
            idx = self.comboBoxFlowlinesStyleType.findText(
                flowlines_style_name
            )
            if idx > -1:
                self.comboBoxFlowlinesStyleType.setCurrentIndex(idx)
            self.checkBoxFlowlines.setChecked(True)
            self.checkBoxFlowlines.setEnabled(True)
            self.flowline_styling_type_changed(
                param_values=flowlines_style_param_values
            )
        else:
            self.checkBoxFlowlines.setEnabled(False)
            self.checkBoxFlowlines.setChecked(False)
        if uncheck_flowlines_checkbox:
            self.checkBoxFlowlines.setChecked(False)

        # Nodes and cells
        filtered_das = filter_demanded_aggregations(
            self.demanded_aggregations, [VT_NODE, VT_NODE_HYBRID]
        )
        if len(filtered_das) > 0:
            if nodes_style is None:
                nodes_style_name = DEFAULT_STYLES[
                    filtered_das[0].variable.short_name
                ]["node"].name
            else:
                nodes_style_name = nodes_style.name
            idx = self.comboBoxNodesStyleType.findText(nodes_style_name)
            if idx > -1:
                self.comboBoxNodesStyleType.setCurrentIndex(idx)
            self.checkBoxNodes.setEnabled(True)
            self.checkBoxNodes.setChecked(True)
            if uncheck_nodes_checkbox:
                self.checkBoxNodes.setChecked(False)

            if cells_style is None:
                cells_style_name = DEFAULT_STYLES[
                    filtered_das[0].variable.short_name
                ]["cell"].name
            else:
                cells_style_name = cells_style.name

            idx = self.comboBoxCellsStyleType.findText(cells_style_name)
            if idx > -1:
                self.comboBoxCellsStyleType.setCurrentIndex(idx)
            self.checkBoxCells.setEnabled(True)
            self.checkBoxCells.setChecked(True)
            if uncheck_cells_checkbox:
                self.checkBoxCells.setChecked(False)

            # Do not automatically set checkBoxRasters to Checked because this requires follow-up input from the user
            self.checkBoxRasters.setEnabled(True)

            self.node_styling_type_changed(
                param_values=nodes_style_param_values
            )
            self.cell_styling_type_changed(
                param_values=cells_style_param_values
            )

        else:
            self.checkBoxNodes.setEnabled(False)
            self.checkBoxCells.setEnabled(False)
            self.checkBoxRasters.setEnabled(False)

            self.checkBoxNodes.setChecked(False)
            self.checkBoxCells.setChecked(False)
            self.checkBoxRasters.setChecked(False)

        # Pumps
        filtered_das = filter_demanded_aggregations(self.demanded_aggregations, [VT_PUMP])
        if len(filtered_das) > 0:
            # Pump (point)
            if pumps_style is None:
                pumps_style_name = DEFAULT_STYLES[filtered_das[0].variable.short_name]["pump"].name
            else:
                pumps_style_name = pumps_style.name
            idx = self.comboBoxPumpsStyleType.findText(pumps_style_name)
            if idx > -1:
                self.comboBoxPumpsStyleType.setCurrentIndex(idx)
            self.checkBoxPumps.setChecked(True)
            self.checkBoxPumps.setEnabled(True)
            self.pump_styling_type_changed(param_values=pumps_style_param_values)

            # Pump (linestring)
            if pumps_linestring_style is None:
                pumps_linestring_style_name = DEFAULT_STYLES[
                    filtered_das[0].variable.short_name
                ]["pump_linestring"].name
            else:
                pumps_linestring_style_name = pumps_linestring_style.name
            idx = self.comboBoxPumpsLinestringStyleType.findText(pumps_linestring_style_name)
            if idx > -1:
                self.comboBoxPumpsLinestringStyleType.setCurrentIndex(idx)
            self.checkBoxPumpsLinestring.setChecked(True)
            self.checkBoxPumpsLinestring.setEnabled(True)
            self.pump_linestring_styling_type_changed(param_values=pumps_linestring_style_param_values)
        else:
            self.checkBoxPumps.setEnabled(False)
            self.checkBoxPumps.setChecked(False)
            self.checkBoxPumpsLinestring.setEnabled(False)
            self.checkBoxPumpsLinestring.setChecked(False)

        if uncheck_pumps_checkbox:
            self.checkBoxPumps.setChecked(False)

        if uncheck_pumps_linestring_checkbox:
            self.checkBoxPumpsLinestring.setChecked(False)

    def checkbox_flowlines_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(FLOWLINES_TAB, self.checkBoxFlowlines.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)

    def checkbox_nodes_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(
            NODES_CELLS_TAB,
            self.checkBoxNodes.isChecked() or self.checkBoxCells.isChecked()
        )
        self.groupBoxNodes.setEnabled(self.checkBoxNodes.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)

    def checkbox_cells_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(
            NODES_CELLS_TAB,
            self.checkBoxNodes.isChecked() or self.checkBoxCells.isChecked()
        )
        self.groupBoxCells.setEnabled(self.checkBoxCells.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)

    def checkbox_pumps_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(
            PUMPS_TAB,
            self.checkBoxPumps.isChecked() or self.checkBoxPumpsLinestring.isChecked()
        )
        self.groupBoxPumps.setEnabled(self.checkBoxPumps.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)

    def checkbox_pumps_linestring_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(
            PUMPS_TAB,
            self.checkBoxPumps.isChecked() or self.checkBoxPumpsLinestring.isChecked()
        )
        self.groupBoxPumpsLinestring.setEnabled(self.checkBoxPumpsLinestring.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)

    def checkbox_rasters_state_changed(self):
        self.tabWidgetStyling.setTabEnabled(RASTERS_TAB, self.checkBoxRasters.isChecked())
        self.activate_first_enabled_tab(self.tabWidgetStyling)
        self.mQgsFileWidgetRasterFolder.setEnabled(self.checkBoxRasters.isChecked())
        self.validate()

    @staticmethod
    def activate_first_enabled_tab(tabwidget):
        """
        If the current active tab is not enabled, switch to the first enabled tab
        or if no tab is enabled, to the first tab
        """
        if not tabwidget.isTabEnabled(tabwidget.currentIndex()):
            for index in range(tabwidget.count() + 1):
                if tabwidget.isTabEnabled(index):
                    tabwidget.setCurrentIndex(index)
                    return
            tabwidget.setCurrentIndex(0)

    def styling_type_changed(
        self, output_type: str, param_values: dict = None
    ):
        if output_type == "flowline":
            params_widget = self.tableWidgetFlowlinesStyleParams
            type_widget = self.comboBoxFlowlinesStyleType
            aggregation_variable_types = [VT_FLOW, VT_FLOW_HYBRID]
        elif output_type == "node":
            params_widget = self.tableWidgetNodesStyleParams
            type_widget = self.comboBoxNodesStyleType
            aggregation_variable_types = [VT_NODE, VT_NODE_HYBRID]
        elif output_type == "cell":
            params_widget = self.tableWidgetCellsStyleParams
            type_widget = self.comboBoxCellsStyleType
            aggregation_variable_types = [VT_NODE, VT_NODE_HYBRID]
        elif output_type == "pump":
            params_widget = self.tableWidgetPumpsStyleParams
            type_widget = self.comboBoxPumpsStyleType
            aggregation_variable_types = [VT_PUMP]
        elif output_type == "pump_linestring":
            params_widget = self.tableWidgetPumpsLinestringStyleParams
            type_widget = self.comboBoxPumpsLinestringStyleType
            aggregation_variable_types = [VT_PUMP]

        else:
            raise ValueError(
                "Invalid output type. Choose one of [node, flowline, cell, pump, pump_linestring]."
            )
        for i in reversed(range(params_widget.rowCount())):
            params_widget.removeRow(i)
        item_data = type_widget.itemData(type_widget.currentIndex())
        type_widget.setEnabled(True)
        if item_data is not None:
            params = item_data.params
            for row, (param_name, param_type) in enumerate(params.items()):
                params_widget.insertRow(row)
                param_name_item = QtWidgets.QTableWidgetItem(param_name)
                params_widget.setItem(row, 0, param_name_item)
                # if param_type == "column":  # here other param types like numbers or text input could be added
                param_input_widget = QtWidgets.QComboBox()

                # Add columns resulting from aggregations to parameter combobox
                param_input_widget.update = MethodType(
                    update_column_widget, param_input_widget
                )
                param_input_widget.update(
                    demanded_aggregations=self.demanded_aggregations,
                    aggregation_variable_types=aggregation_variable_types,
                )
                params_widget.setCellWidget(row, 1, param_input_widget)
        if param_values is not None:
            for param, value in param_values.items():
                row = params_widget.findItems(param, Qt.MatchFixedString)[0].row()
                params_input_widget = params_widget.cellWidget(row, 1)
                idx = params_input_widget.findText(value)
                params_input_widget.setCurrentIndex(idx)

    def node_styling_type_changed(
        self, signal: int = 1, param_values: dict = None
    ):
        self.styling_type_changed(
            output_type="node", param_values=param_values
        )

    def cell_styling_type_changed(
        self, signal: int = 1, param_values: dict = None
    ):
        self.styling_type_changed(
            output_type="cell", param_values=param_values
        )

    def flowline_styling_type_changed(
        self, signal: int = 1, param_values: dict = None
    ):
        self.styling_type_changed(
            output_type="flowline", param_values=param_values
        )

    def pump_styling_type_changed(
        self, signal: int = 1, param_values: dict = None
    ):
        self.styling_type_changed(
            output_type="pump", param_values=param_values
        )

    def pump_linestring_styling_type_changed(
        self, signal: int = 1, param_values: dict = None
    ):
        self.styling_type_changed(
            output_type="pump_linestring", param_values=param_values
        )

    def raster_resolution_changed(self):
        self.doubleSpinBoxNodesLayerResolution.setValue(
            self.doubleSpinBoxResolution.value()
        )

    def nodes_layer_resolution_changed(self):
        self.doubleSpinBoxResolution.setValue(
            self.doubleSpinBoxNodesLayerResolution.value()
        )

    def update_gr(self, results_3di, gridadmin):
        if os.path.isfile(results_3di) and os.path.isfile(gridadmin):
            self.gr = GridH5ResultAdmin(gridadmin, results_3di)
            crs = QgsCoordinateReferenceSystem(
                "EPSG:{}".format(self.gr.epsg_code)
            )
            self.mExtentGroupBox.setOutputCrs(crs)
            output_timestep_best_guess = int(
                self.gr.nodes.timestamps[-1]
                / (len(self.gr.nodes.timestamps) - 1)
            )
            self.doubleSpinBoxStartTime.setMaximum(
                int(self.gr.nodes.timestamps[-1])
            )
            self.doubleSpinBoxStartTime.setSingleStep(
                output_timestep_best_guess
            )
            self.doubleSpinBoxEndTime.setSingleStep(output_timestep_best_guess)
            self.doubleSpinBoxEndTime.setMaximum(
                int(self.gr.nodes.timestamps[-1])
            )
            self.doubleSpinBoxEndTime.setValue(
                int(self.gr.nodes.timestamps[-1])
            )
            self.doubleSpinBoxResolution.setValue(self.gr.grid.dx[0])
            self.doubleSpinBoxNodesLayerResolution.setValue(self.gr.grid.dx[0])
            if self.mQgsFileWidgetRasterFolder.filePath() == "":
                results_3di_dir = os.path.dirname(results_3di)
                self.mQgsFileWidgetRasterFolder.setFilePath(results_3di_dir)
        else:
            self.gr = None

        self._update_variable_list()

    def results_3di_selected(self, index):
        result_id = self.resultComboBox.itemData(index)
        result = self.model.get_result(result_id)
        results_3di = result.path
        gridadmin = result.parent().path.with_suffix('.h5')
        assert os.path.isfile(results_3di) and os.path.isfile(gridadmin)
        self.update_gr(str(results_3di), str(gridadmin))
        if self.validate():
            self.result_id = result_id

    def add_result(self, result_item: ThreeDiResultItem) -> None:
        currentIndex = self.resultComboBox.currentIndex()
        self.resultComboBox.addItem(f"{result_item.parent().text()} | {result_item.text()}", result_item.id)
        self.resultComboBox.setCurrentIndex(currentIndex)

    def remove_result(self, result_item: ThreeDiResultItem):
        idx = self.resultComboBox.findData(result_item.id)
        logger.info(f"Removing result {result_item.id} at index {idx}")
        assert idx != -1
        if idx == self.resultComboBox.currentIndex():
            # TODO: clean up?
            self.resultComboBox.setCurrentIndex(-1)

        self.resultComboBox.removeItem(idx)

    def change_result(self, result_item: ThreeDiResultItem):
        idx = self.resultComboBox.findData(result_item.id)
        assert idx != -1
        self.resultComboBox.setItemText(idx, f"{result_item.parent().text()} | {result_item.text()}")

    def set_extent_from_map_canvas(self):
        canvas_extent = self.iface.mapCanvas().extent()
        project = QgsProject.instance()
        crs = project.crs()
        self.mExtentGroupBox.setOutputExtentFromUser(canvas_extent, crs)

    def preset_combobox_changed(self, index):
        preset = self.comboBoxPreset.itemData(index)

        # Check whether the currently selected model support the preset's aggregations
        if self.gr:
            containing_information = self._retrieve_model_info()
            for agg_var in preset.aggregations():
                missing_info = [item for item in agg_var.variable.requirements if item not in containing_information]
                if missing_info:
                    pop_up_critical(f"The currently selected 3Di model does not contain all required info for aggregation '{agg_var.variable.long_name}': {[VR_NAMES[item] for item in missing_info]}")
                    no_preset_idx = self.comboBoxPreset.findText(NO_PRESET.name)
                    self.comboBoxPreset.setCurrentIndex(no_preset_idx)  # reset to no preset
                    return

        self.presetHelpTextBrowser.setText(preset.description)
        self.apply_preset(preset)
        self._update_variable_list()

    def apply_preset(self, preset: Preset):
        """
        Set dialog widgets according to given preset.
        If no styling is given for an output_type, that output type's styling panel checkbox is set to False
        """

        # Set the default output layer names based on preset, if the current layer name value is not modified yet
        if not self.lineEditOutputFlowLayer.isModified():
            self.lineEditOutputFlowLayer.setText(preset.flowlines_layer_name or "")

        if not self.lineEditOutputCellLayer.isModified():
            self.lineEditOutputCellLayer.setText(preset.cells_layer_name or "")

        if not self.lineEditOutputNodeLayer.isModified():
            self.lineEditOutputNodeLayer.setText(preset.nodes_layer_name or "")

        if not self.lineEditOutputPumpsLayer.isModified():
            self.lineEditOutputPumpsLayer.setText(preset.pumps_layer_name or "")

        if not self.lineEditOutputPumpsLinestringLayer.isModified():
            self.lineEditOutputPumpsLinestringLayer.setText(preset.pumps_linestring_layer_name or "")

        if not self.lineEditOutputRasterLayer.isModified():
            self.lineEditOutputRasterLayer.setText(preset.raster_layer_name or "")

        # set manhole filter
        self.onlyManholeCheckBox.setChecked(preset.only_manholes)

        # remove existing aggregations
        self.tableWidgetAggregations.setRowCount(0)

        # add aggregations from preset
        for da in preset.aggregations():
            self.add_aggregation(aggregation=da, update_output_layer_names=(preset == NO_PRESET))

        # set "resample point layer" from preset
        self.checkBoxResample.setChecked(preset.resample_point_layer)

        # set styling from preset
        self.set_styling_tab(
            flowlines_style=preset.flowlines_style,
            nodes_style=preset.nodes_style,
            cells_style=preset.cells_style,
            pumps_style=preset.pumps_style,
            pumps_linestring_style=preset.pumps_linestring_style,

            flowlines_style_param_values=preset.flowlines_style_param_values,
            nodes_style_param_values=preset.nodes_style_param_values,
            cells_style_param_values=preset.cells_style_param_values,
            pumps_style_param_values=preset.pumps_style_param_values,
            pumps_linestring_style_param_values=preset.pumps_linestring_style_param_values,

            uncheck_flowlines_checkbox=preset.flowlines_style is None,
            uncheck_nodes_checkbox=preset.nodes_style is None,
            uncheck_cells_checkbox=preset.cells_style is None,
            uncheck_pumps_checkbox=preset.pumps_style is None,
            uncheck_pumps_linestring_checkbox=preset.pumps_linestring_style is None,
        )

    def _update_output_layer_fields_based_on_aggregations(self):
        logger.info("Output layer suggestion based on selected aggregations")

        # Set the default output layer names based on preset, if the current layer name value is empty
        suggested_flow_output_layer_name = "Flowlines: "
        suggested_cell_output_layer_name = "Cells: "
        suggested_node_output_layer_name = "Nodes: "
        suggested_pump_output_layer_name = "Pumps (points): "
        suggested_pump_linestring_output_layer_name = "Pumps (lines): "
        suggested_raster_output_layer_name = "Raster: "

        postfix = ""
        if len(self.demanded_aggregations) == 0:
            postfix = "aggregation output layer"
        elif len(self.demanded_aggregations) == 1:
            aggregation = self.demanded_aggregations[0]
            postfix_items = [aggregation.variable.long_name]
            if aggregation.variable.signed:
                postfix_items.append(aggregation.sign.long_name.lower())
            if aggregation.method:
                postfix_items.append(aggregation.method.long_name.lower())
            postfix_items.append(f"[{aggregation.unit_str}]")  # attribute attached in update_demanded_aggegrations()
            postfix = " ".join(postfix_items)
        else:
            postfix = "multiple aggregations"

        if not self.lineEditOutputFlowLayer.isModified():
            self.lineEditOutputFlowLayer.setText(suggested_flow_output_layer_name + postfix)

        if not self.lineEditOutputCellLayer.isModified():
            self.lineEditOutputCellLayer.setText(suggested_cell_output_layer_name + postfix)

        if not self.lineEditOutputNodeLayer.isModified():
            self.lineEditOutputNodeLayer.setText(suggested_node_output_layer_name + postfix)

        if not self.lineEditOutputPumpsLayer.isModified():
            self.lineEditOutputPumpsLayer.setText(suggested_pump_output_layer_name + postfix)

        if not self.lineEditOutputPumpsLinestringLayer.isModified():
            self.lineEditOutputPumpsLinestringLayer.setText(suggested_pump_linestring_output_layer_name + postfix)

        if not self.lineEditOutputRasterLayer.isModified():
            self.lineEditOutputRasterLayer.setText(suggested_raster_output_layer_name + postfix)

    def _retrieve_model_info(self):
        containing_information = []
        if self.gr:
            if self.gr.has_simple_infiltration:
                containing_information.append(VR_SIMPLE_INFILTRATION)
            if getattr(self.gr, "has_interflow", True):
                containing_information.append(VR_INTERFLOW)
            elif self.gr.has_interflow:
                containing_information.append(VR_INTERFLOW)
            if self.gr.has_interception:
                containing_information.append(VR_INTERCEPTION)
            if self.gr.has_pumpstations:
                containing_information.append(VR_PUMP)

        return containing_information

    def _update_variable_list(self):
        # Tterate over the rows and check the items in the variable combobox: disable variable when currently loaded
        # model is not supporting this variable
        containing_information = self._retrieve_model_info()

        row_count = self.tableWidgetAggregations.rowCount()
        for row in range(row_count):
            variable_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_VARIABLE)
            #  Iterate over the variables in the combobox
            for item_idx in range(variable_widget.count()):
                variable = variable_widget.itemData(item_idx)

                if self.gr:
                    missing_info = [item for item in variable.requirements if item not in containing_information]
                    if missing_info:
                        if item_idx == variable_widget.currentIndex():
                            pop_up_critical(f"The currently selected model does not contain all required info for aggregation '{variable.long_name}': {[VR_NAMES[item] for item in missing_info]}")
                        variable_widget.model().item(item_idx).setEnabled(False)
                    else:
                        variable_widget.model().item(item_idx).setEnabled(True)
                else:
                    variable_widget.model().item(item_idx).setEnabled(True)

    def update_demanded_aggregations(self):
        self.demanded_aggregations = []
        row_count = self.tableWidgetAggregations.rowCount()
        for row in range(row_count):
            # Variable
            variable_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_VARIABLE)
            variable = variable_widget.itemData(variable_widget.currentIndex())

            # Direction
            direction_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_DIRECTION)
            sign = direction_widget.itemData(direction_widget.currentIndex())

            # Method
            method_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_METHOD)
            method = method_widget.itemData(method_widget.currentIndex())

            # Threshold
            threshold_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_THRESHOLD_VALUE)
            if method is not None and method.threshold_sources:
                threshold = threshold_widget.currentText()
            else:
                threshold = threshold_widget.value()

            # Multiplier (unit conversion)
            units_widget = self.tableWidgetAggregations.cellWidget(row, COLUMN_UNITS)
            multiplier = units_widget.itemData(units_widget.currentIndex())

            da = Aggregation(
                variable=variable,
                sign=sign,
                method=method,
                threshold=threshold,
                multiplier=multiplier,
            )

            # For visualisation-purposes we also (redundantly) attach the unit text
            da.unit_str = units_widget.currentText()

            if da.is_valid():
                self.demanded_aggregations.append(da)

            else:
                # This method is often called due to a signal being fired, but this can also happen when the contents of
                # the row's widgets are not yet complete, i.e. the information in the row cannot be tranlated to a
                # valid Aggregation instance. We just continue, but self.demanded_aggregations_are_valid() will now
                # return False until update_demanded_aggregations() will be called again with valid contents in the
                # aggregations table
                return

        self.set_styling_tab()

    def demanded_aggregations_are_valid(self) -> bool:
        """
        Checks if the contents of the table of demanded aggregations can be interpreted in a valid way
        """
        if self.tableWidgetAggregations.rowCount() != len(
            self.demanded_aggregations
        ):
            return False
        if not all([da.is_valid() for da in self.demanded_aggregations]):
            return False
        return True

    def validate(self) -> bool:
        valid = True

        logger.info([agg.variable.long_name for agg in self.demanded_aggregations])
        if not isinstance(self.gr, GridH5ResultAdmin):
            logger.warning("Invalid or no result file selected")
            valid = False
        if not self.tableWidgetAggregations.rowCount() > 0:
            logger.warning("Zero aggregations selected")
            valid = False
        if (
            self.checkBoxRasters.isChecked()
            and self.mQgsFileWidgetRasterFolder.filePath() == ""
        ):
            logger.warning("No raster folder selected")
            valid = False
        if not self.demanded_aggregations_are_valid():
            logger.warning("Demanded aggregations are not valid")
            valid = False

        # Check whether the demanded aggregations are compatible with the model (or: model contains all required info)
        if self.gr:
            containing_information = self._retrieve_model_info()

            for agg in self.demanded_aggregations:
                missing_info = [item not in containing_information for item in agg.variable.requirements]
                if missing_info:
                    logger.warning(f"Model does not contain all info for demanded aggregations: {[VR_NAMES[item] for item in missing_info]}")
                    valid = False
                    break

        self.dialogButtonBoxOKCancel.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(valid)

        return valid
